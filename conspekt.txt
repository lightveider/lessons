байт код проверяется поледовательно
В случае если инструкция в байт коде ошибка происходит прерывание 
компиляция в JDK выполнение в JDE 
ide не может работать без jdk
Папка .idea  и java_lessons.iml  папки среды , не трогать
Папка srс создается средой 
Папка может называться как угодно должна быть отмечена синим цветом папки, если нет то mark directory as soursec root
File projeсt struсture  {
Project language lvl не может быть выше чем SDK 
 В папку out складываются файлы .class  c байт  кодом 
  }
  Код cоcтоит из клаccов cодержащих данные 
  каждый клаcc cоздаётcя в новом файле
  минимальная программа один клаcc 
  Пакет внутри папки src обычная директория
  имена пакетов именуютcя c маленькой буквы и без кирилицы
  Название клаccа должно соответсовать 
  название класса должно начинаться  с большой буквы 
 !!!!! Если название класса состоит из нескольких слов то каждое слово с заглавной буквы 
 Комментарии в java сtrl  + /
 Одно приложение одна точка входа 
 psvm - разворот точки входа
 инструкции разделяются ;
 Типы данных: 
	Примитивные данные
	ссылочные данные 
К примитивным типам данных отноcятcя целые чиcла 
4 типа данных отноcятcя к целым чиcлам
они отличаютcя диапазонами значений 
и размером  в памяти и принимаемым значением
byte - 1 байт - от -128 до 127 для экономии памяти и передачи данных по cети
short - 2 байта - от -32768 до 32767  наиболее редко иcпользуемый
int - 4 байта - от -2147483648 до 2147483647 
long - 8 байт - большие чиcла

Операции над byte and short приводят к типу int 

Чиcла c плавающей точкой
float  4байта
double 8байт
Виртуальные машины оптимизированны под работу c double

cимвольный тип данных для одного cимвола cтраницы unicode
char -2byte

Логичеcкий типы 
boolean - завиcит от реализации jvm 4 байта / 1 байт в маccивах  , иcпользуетcя в циклах и уcловиях
Значения true \ false


Имена переменных должны отражать cуть, имена переменных c маленькой буквы, каждое поcледующее cлово c заглавной буквы

Приcваивать значение ранее объявленным переменным только раздельно

Внутри одной облаcти видимоcти может быть только одна переменная
облаcть видимоти это фигурные cкобки {};

Для работы c Float в конце чиcла надо cтавить F;

Для точных вычислений для double и float необходимо использовать класс java.math.BigDecimal

Литералы 

Приведение типов 
1) Автоматическое преобразование ( возможно если типы совместимы)
2) Явное приведение типов


Если типы совместимы и преобразование идет с расширением контейнера то будет автоматическое преобразование

Арифметические операторы
+ сложение
- вычитание
* умножение
/ целочисленное деление 
% взятие остатка от деления

+ перед byte short char  приводит к int 
также для сложения строк без пробелов

Операторы присваивания 
= присваивание


Каждый оператор сравнения возращает true or false

сtrl + alt + l выравние кода 

логические операторы возвращают тру / фалсе 

|| оператор или, после проверки первой переменной в случае с true вторую переменную не проверяет 
оператор && ( и) возвращает true  если оба операнда true 
если первая операнда false то оператор возвращает false
! возвращает true/ false 
исключающее или работает с двумя операндами , возвращает тру только если один из операнд тру
xor работает только с двумя операндами 
сначала считаются инкременты и декременты
если инкремент и декремент находятся поле переменной то это постфиксная форма инкремента и дикремента
если инкремент или декремент перед то это префиксная форма

Переименование класса пкм-рефактор - ренейм

поставить курсор alt + enter  импорт класса 
if (выражение/ условие/ canсeled(done) ){}
если инструкция одна то можно не использовать фигурные скобки

else  только дополненеие к if 
if (логическое выражение ==  или булиан) {инструкции которые выполнятся если выражение true}
if может быть дополняться else if 
if -> доп условия в else if -> и потом только else 
if и else всегда один
else if много 

Если требуется проверить 3 различных условия то надо три отдельных if 

switch (выражение / переменная ) 
switch может быть байт/шорт/инт/чар/enum/стринг

switch ( выражение / переменная) {

	сase значение1: 
	инструкции
	[break]

инструкции будут выполняться все инструкции до брейка или до конца 
от первого совпадения до брейка или до конца без проверок
блок default необязателен
выполняется если ничего не совпало 

циклы использутся для однотипных действий
пока выражения тру 

while ( логическое выражение / уcловие / булевый тип - главное)  { в фигурных скобках любые инструкции,}
если в () тру - то бесконечный цикл
если в () фалсе - не совершит ни одной итерации

одно повторение тела цикла - иттерация


for (инициализация счетчиков;условие; обновление счетчиков) 
инициализация счетчиков выполняется только один раз
проверяется условиевыполняется тело цикла 
//Math.random() от 0 до 1 не включая 1 ( 0.1 ,0.20 0.9) 

Каждый проект надо брать под версионный контроль отдельно
сделали первое дз сделали коммит , сделали второе дз, сделали коммит
в каждом проекте должен быть гитигнор с файлами 
out
.idea
*.iml

после одной настройки гита 
git add .
git commit
git push


GIT в IDEA


VCS (GIT) import vith vesion control - github
репозиторий сам создастся на гитхабе 
пкм на красном файле add file 
commit выбирать файлы для коммита 



д/з : клонирвание пулл коммиты  пуши
перемешение коммита 
ветвление 
привести дз ранее в порядок
выложить на гитхаб 
прислать личную ссылку на гитхаб

в названии проектов быть не должно
папка src

сканнер это ссылочный тип, true будет только если они ссылаются на один объект.

Массивы позволяют хранить набор данных как неприрывную область памяти
Значения в массиве должны быть одного типа 
Массив это ссылочный тип
Значения массива могут быть ссылочного типа или примитивами
Каждое значение которое хранится внутри массива называется элементом массива
Элементы внутри массива хранятся в виде индексов
!! Нумерация начинается  с нуля (0) 
У массива есть длинна, длинна массива это int и индексы это int
Длинна массива неизменна вообще 
Массивы наиболее быстраа структура данных
Массивы байт шорт инт лонг заполняются 0
дабл и флоат 0.0
boolean заполняется false 
char заполняется '\u0000'

Длинну массива можно указать через переменную
явно указать
через выражение , главное чтобы в итоге был тип инт int [] inst2 = new int[len * 2]
В квадратных скобках массив должен быть наполнен потом
в фигурныз наполняется указанными значениями
 //ints3 ={2,5,7,123}; так нельзя
//new int [] {123,123,321} - "безымянный массив" нужно для того чтобы переписать ссылку и переменная ссылалась на другой массив

При выводе любого ссылочного типа в консоль (sout) выводится хэш-код
Arrays 
В языке есть класс Arrays 
в классе Arrays собраны методы для работы  с массивами 

Доументация класс. javadoc
Документацию ниже 8 версии не смотреть 


char хранит один символ юникод
// от 0 до 65536 либо ESC последовательность  от '\u0000' до  '\uffff'
        
строки в языке упорядоченная последовательность символов
Все строки в языке это ссылочные типо , объекты
строки задаются либо в двойных кавычках

Надо пользоваться исключительно через ковычки
в очень редких случаях использовать new String()


Правильно именовать пакеты
домен(ru. / com. ) потом организация
com.ifmo.jjd - необходимо для избежания конфликта имен

В классе перечисляются характиристики объектов ( свойства объектов) и возможности ( методы)
Точка входа только в одном классе

проверки свойств происходят в самом классе

без модификатора доступен внутри пакета ( в lesson6 доступен а в лессон5 нет)

Методы setter устанавливаются в паблик
Модификаторы работают  с методами, свойствами и классами
Методы устанавливающие значения Setter
Методы возвращающие значения Getter
Getter - это метод который возвращает значения свойств

Если значения свойств не установленны то значения для свойств устанавливаются в значения по умолчанию
Для всех ссылочных типов это null
для целочисленных 0
для доубле 0.0
для булевых false


если методы нужны только для внутреннего использования используем public
конструкторов может быть сколько угодно главное чтобы они отличались модификаторами(в скобочках инт и стринг)
(типом и количеством)

класс не может наследовать множество классов
Дочерний класс получает свойства
protected это метод который позволяет обратиться к методу только из дочернего класса
Наследование предпологает расширение функционала
Конструкторы не наследуются
если у родителя нет конструктора по умолчанию то в дочернем классе обязательно должен быть конструктор который вызывает
конструктор родителя
конструктор ребенка не обязан повторять конструктор родителя, главное чтобы конструктор родителя вызывался
если у родителя несколько конструкторов, надо вызвать хотя бы один
если массив или коллекция создается из родительского ( то так же можно использовать любого из наследников)
При обращении к объекту из данного массива будут доступны методы и свойства только родительского массива
методы и свойства ребенка не доступны!
доступны только методы и свойства описанные родителя
Основное назначение интерфейса методы без реализации
в методе без реализации нет фигурных скобок
у интерфейсов не может быть конструкторов
Объект на основе интерфейса создать нельзя ни при каких условиях
Помимо интерфейсов существуют абстрактные классы
Абстрактные классы это обычные классы в нем могут быть свойства методы с реализацией  конструкторы
могут иметь детей и родителей
но
экземпляр абстрактного класса создать нельзя
и абстрактные могут иметь обстрактные методы
наличие интерфейса предпологает наличие нескольких классов в которых должны быть
использованны методы используемые в интерфейсе
Класс имплиментирует ( реализует) любой интерфейс
Один класс может имплиментировать сколько угодно интерфейсов
Интерфейс обязывае класс  реализовать все абстрактные методы которые в нем перечисленны
на усмотрение класса
Абстрактный класс может иметь методы без реализации
Интерфейс так же может быть указан в качестве общего типа данных
s

31.01

Если есть метод с реализацией его можно переопределить или использовать в виде описанном в интерфейсе

Конфликт методов из билиотек приведет к тому что надо писать свою реализацию методов

Final могут быть классы свойства методы
если класс объявлен как final у него не может быть наследников
final могут быть методы, если метод объявлен как final его нельзя переопределить в дочернем классе
final могут быть свойства класса
final свойства должны быть инициализированы при объявлении либо присвоить  в конструкторе
Значение final свойства изменить нельзя
если это примитив то впринципе нельзя увеличить значение свойства
если это ссылочный тип то нельзя переписать ссылку
final могут быть аргументы метода
если это примитив то мы не можем изменить значения
если ссылочный тип то мы не можем переписать ссылку
getter для final свойства можно создать , setter нельзя

Static могут быть только вложенные классы
Static могут быть свойства,методы блоки

статический блок может быть в классе один - вместо конструктора для статических
в статическом блоке можем вызывать статические методы
Наличие статического блока необязательно
Инструкции внутри статического блока выполняются только один раз когда класс прогружается в память



модификатор доступа static  тип данных потом имя переменных
! НО статические свойства не являются характеристиками объекта.
Static нельзя использовать как модификатор объекьа

Static final - хранение констант без создания объекта

статические методы - вспомогательные/ обслуживающие методы  как Arrays objects
статические методы не принадлежат объекту, а принадлежат классу
Фабричные методы - которые создают объект
Для обращения к статическим свойствам для вызова статических методов не нужно создавать объект
Пишем имя класса потом точку потом либо статического свойства либо имя статического метода

Перегруженные методы - могут отличаться типов или количеством элементов, типом данных но называются одинаково

Константы final static пишутся полностю в верхнем регистре каждое последующее слово отделяется нижним подчеркиванием

Импорт статическим методов позволяет вызывать метод / свойсвто
Благодаря статическому методу
У Object есть метод getClass который возвращает ссылку на класс объекта

Метод equals переопределяется вместе с методом hashcode

Оператор instanceof проверяет имеет ли отношение данный объект к указанному типу данных
Интерфейсы маркеры - Cloneable, интерфейс без методов

При реализации метода clone никто не запрещает создание метода с улучшенными или ухудшенными характеристиками

При клонировании создался массив

